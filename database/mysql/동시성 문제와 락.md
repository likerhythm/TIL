# MySQL의 동시성 문제와 락
DBMS는 동시성 문제를 해결하기 위해 보통 락(Lock)을 사용합니다.
락은 크게 **공유락**과 **베타락**으로 나눌 수 있습니다.
이번 글에서는 동시성 문제의 해결책인 공유락과 베타락이 무엇인지, 그리고 어떻게 동시성 문제를 해결하는지 알아보겠습니다. 

# 동시성 문제
> 동시성 문제가 뭔가요?

두 트랜잭션이 같은 데이터에 접근해야 하는 경우 동시성 문제가 발생할 수 있습니다.
대표적으로 예매 시스템을 예로 들 수 있습니다. 유명 가수의 콘서트 티켓을 예매하기 위해 컴퓨터 앞에 앉아있다고 생각해봅시다.
그리고 전국에 10만명이 같은 콘서트를 예매하기 위해 기다리고 있습니다.
3..2..1.. 예매 창이 열리면서 드디어 예매를 할 수 있게 됐습니다.
그 순간 예매 서버에는 수만개의 예매 요청이 몰리게 됩니다. 그리고 각 요청은 하나의 트랜잭션으로 볼 수 있습니다.

여기서 동시성 문제를 고려하지 않은 경우에 어떤 문제가 생기는지 알아보겠습니다.
각 트랜잭션은 데이터베이스에서 공연장의 남은 좌석 수를 조회(SELECT)합니다.
그러면서 동시에 클릭 속도가 빠른 어떤 사람은 순식간에 예매를 완료하기도 합니다.
즉, 공연장의 남은 좌석 수 데이터가 조회되는 동시에 갱신(UPDATE)되었습니다.

이렇게 같은 데이터에 대하여 SELECT, UPDATE가 동시에 이루어 진다면 문제가 발생할 수 있습니다.
특히, UPDATE가 동시에 이루어지면 좌석을 예매 했음에도 데이터베이스에는 다른 사람이 예매한 것으로
저장될 수 있습니다.

이렇게 여러 트랜잭션이 동시에 같은 데이터에 접근할 때 발생할 수 있는 문제가 **동시성 문제**입니다.

# 락(Lock)
락은 동시성 문제를 해결하기 위한 대표적인 방법입니다.
락은 여러 트랜잭션이 같은 데이터에 접근할 때 데이터의 일관성이 유지되도록 하기 위해
데이터를 잠그는 메커니즘입니다.

락의 종류는 DBMS마다 다양하지만 대부분은 공통적으로 공유락과 베타락을 두고 있습니다.
MySQL의 공식 문서를 참고하여 공유락과 베타락을 정리해보았습니다.

## 공유락(Shared Lock, S Lock)
공유락을 획득한 트랜잭션은 공유락이 잠그고 있는 데이터에 '읽기' 접근이 가능합니다.
만약 다른 트랜잭션이 같은 데이터를 읽기 위해 공유락을 요청한다면 이를 바로 허용할 수 있습니다.
즉, 데이터를 읽기 위한 공유락은 바로 획득할 수 있고 공유락을 획득한 트랜잭션이라면
누구든지 공유락이 잠그고 있는 데이터에 읽기 접근이 가능합니다.
하지만 공유락이 걸린 데이터의 베타락은 획득할 수 없습니다.

## 베타락(Exclusive Lock, X Lock)
베타락을 획득한 트랜잭션은 베타락이 잠그고 있는 데이터에 '쓰기' 접근이 가능합니다.
데이터를 이미 쓰고(write)있는 트랜잭션 T1이 있다면 해당 데이터의 공유락과 베타락은
T1이 종료될 때까지 얻을 수 없습니다.

# 쓰기 - 쓰기 동시성 문제
이제 락으로 어떤 문제를 해결하고자 하는지 알아보겠습니다.
먼저 쓰기 - 쓰기 상황에서의 동시성 문제가 있습니다.
> 쓰기 - 쓰기 상황?

쓰기 - 쓰기 상황은 두 트랜잭션 T1, T2가 같은 데이터를 동시에 UPDATE하려는 상황입니다.
이 경우 **갱신 손실 문제**가 발생할 수 있습니다.
> 갱신 손실 문제?

갱신 손실 문제란 두 트랜잭션의 갱신 작업 중 하나가 무효화 되는 문제입니다.
이 문제는 의도한 게 아니라면 데이터베이스에서 **절대** 일어나선 안되는 문제입니다.
이를 해결하기 위해서 락을 사용합니다.

> 어떻게 문제를 해결하나요?

먼저 갱신 작업이 시작할 때 락을 부여하고 작업이 끝나면 바로 락을 반환하는 방법이 있습니다.
트랜잭션 T1이 데이터를 갱신하는 경우 데이터에 락을 걸어서 다른 트랜잭션 T2가
해당 데이터를 갱신하지 못하도록 막습니다.
T1의 작업이 완료되면 T2는 데이터에 접근할 수 있습니다.

하지만 이 방법의 경우 하나의 트랜잭션이 여러 데이터를 갱신하려는 경우 문제가 발생할 수 있습니다.
다음 표를 통해 상황을 설명해보겠습니다.

|       트랜잭션 T1(Data A, B에 접근 필요)        |  트랜잭션 T2(Data A, B에 접근 필요)   |DATA A| DATA B |
|:--------------------------------------:|:----------------------------:|:----:|:-------:|
|      Data A가 30이고 Data B가 30임을 확인      |              -               |  30  |30|
| DATA A를 갱신하기 위해 Lock A 획득. A - 10으로 갱신 |              -               |  20  |30|
|                   -                    |              -               |  20  |30|
|               Lock A 반납                | Data A가 20이고 Data B가 30임을 확인 |  20  |30|
|                   -                    |   Lock A 획득 후 A를 + 10으로 갱신   |  30  |30|
|                   -                    |   Lock B 획득 후 B를 - 10으로 갱신   |  30  |20|
|          Lock B를 획득하기 위해 대기 중          |              -               |  20  |30|
|                   -                    |          Lock B 반납           |  30  |20|
|        Lock B 획득 후 B + 10으로 갱신         |              -               |  30  |30|              

위 표를 보면 트랜잭션 T1은 처음에 조회한 Data B 값과 연산 후의 값이 30으로 같아지게 되는 문제가 발생할 수 있음을 알 수 있습니다.
쉽게 말하면 트랜잭션 T1 종료 결과 Data B가 40일 것이라 예상했지만 30이었기에 아무런 작업이 이루어지지 않은 것처럼 보인다는 것이죠.
이러한 문제는 **2단계 락킹**을 사용하여 해결할 수 있습니다.

> 2단계 락킹?

2단계 락킹은 락을 획득하고 반환하는 시점을 두 단계로 나누어서 획득과 반환이 교차로 일어나는 상황을 방지합니다.
각 단계는 확장 단계, 해제 단계로 나뉩니다.

- 확장단계 : 여러 락이 필요한 경우(여러 데이터에 접근이 필요한 트랜잭션인 경우)에는
락을 획득할 때 이전에 획득한 락을 해제하지 않습니다.
- 해제 단계 : 락을 해제할 때는 새로운 락을 획득하지 않고 모든 락을 해제한다.

2단계 락킹을 적용한 예시를 살펴보겠습니다.

|                트랜잭션 T1(Data A, B에 접근 필요)                |트랜잭션 T2(Data A, B에 접근 필요)|DATA A| DATA B |
|:-------------------------------------------------------:|:-----------------------:|:----:|:-------:|
|                     Data A가 30임을 확인                     |              -               |  30  |30|
|         DATA A를 갱신하기 위해 Lock A 획득. A - 10으로 갱신          |              -               |  20  |30|
|Data B가 30임을 확인|-|20|30|
| Data B를 갱신하기 위해 Lock B 획득. B + 10으로 갱신. Lock A는 해제하지 않음 |-|20|40|
|                    Lock A와 Lock B 반납                    |Data A가 20이고 Data B가 40임을 확인|20|40|
|                            -                            |Data A를 갱신하기 위해 Lock A 획득. A + 10으로 갱신|30|40|
|                            -                            |Data B를 갱신하기 위해 Lock B 획득. B - 10으로 갱신|30|30|
|                            -                            |Lock A와 Lock B 반납|30|30|

2단계 락킹을 사용한 결과 T1이 Lock B를 획득할 때 Lock A를 해제하지 않으므로 이전과 같은 문제가 발생하지 않음을 알 수 있습니다.

하지만 2단계 락킹을 사용하면 **데드락** 문제가 발생할 수 있습니다.
위 예시에서 T2가 Lock B, Lock A 순으로 락을 획득할 경우 발생하는 문제입니다.
데드락이 발생할 경우 DBMS는 두 트랜잭션 중 하나를 강제로 종료합니다.
아래 표와 함께 왜 데드락 문제가 발생하는지 알아보겠습니다.

|               트랜잭션 T1(Data A, B에 접근 필요)                |                트랜잭션 T2(Data A, B에 접근 필요)                |DATA A| DATA B |
|:------------------------------------------------------:|:-------------------------------------------------------:|:----:|:-------:|
|                    Data A가 30임을 확인                     |                            -                            |  30  |30|
| DATA A를 갱신하기 위해 Lock A 획득. A - 10으로 갱신 Lock A는 해제하지 않음 |                            -                            |  20  |30|
|                           -                            |                     Data B가 30임을 확인                     |20|30|
|                           -                            | Data B를 갱신하기 위해 Lock B 획득. B + 10으로 갱신. Lock B는 해제하지 않음 |20|40|
|                (Lock B를 획득하기 위해 대기...)                 |                 (Lock A를 획득하기 위해 대기...)                 |20|40|

위 표와 같이 2단계 락킹을 사용하면 T1과 T2가 서로의 락을 획득하기 위해 무한 대기하는 현상이 발생할 수 있습니다.
이 경우 DBMS는 두 트랜잭션 중 하나를 강제로 종료합니다.

# 쓰기 - 읽기 동시성 문제
지금까지는 락을 사용하지 않는 경우 쓰기 - 쓰기 상황에서 발생할 수 있는 문제들은 무엇이고 
락을 통해 어떻게 해결하는지 알아보았습니다.
지금부터는 쓰기 - 읽기 상황에서 발생할 수 있는 문제와 그 해결 방안에 대해 알아보겠습니다.

> 쓰기 - 읽기 상황?

쓰기 - 읽기 상황은 두 트랜잭션이 같은 데이터에 대하여 각각 쓰기(write), 읽기(read) 작업을 수행하려는 상황입니다.
이 경우 쓰기 - 쓰기 상황에서 발생하는 '갱신 손실'과 같이 심각한 문제는 발생하지 않습니다.
하지만 **오손 읽기(Dirty Read)**, **반복 불가능 읽기(Non-Repeatable Read)**, **유령 데이터 읽기(Phantom Read)** 문제 등이 발생할 수 있습니다.
이 문제들은 데이터의 손실이 일어나는 문제는 아니지만 애플리케이션의 요구사항에 따라 문제가 될 수 있습니다.
문제를 하나씩 알아보며 그 해결 방안에 대해서는 아래에서 한 번에 알아보겠습니다.

## 오손 읽기(Dirty Read) 문제
오손 읽기 문제는 쓰기 - 읽기 상황에서 발생할 수 있는 문제 중 가장 크리티컬한 문제라고 할 수 있습니다.
오손 읽기 문제는 하나의 트랜잭션 T1이 아직 커밋되지 않은 다른 트랜잭션 T2를 읽을 때 발생하는 문제입니다.
이 경우 T2가 ROLLBACK하게 되면 문제가 발생합니다.
다음 표를 보시겠습니다.

|       트랜잭션 T1(읽기)       | 트랜잭션 T2(쓰기) | A  |
|:-----------------------:|:-----------:|:--:|
|            -            |      -      | 30 |
|            -            | A=21로 업데이트  | 21 |
|    A가 21임을 확인(read)     | - | 21 |
| A=21을 바탕으로 애플리케이션 로직 수행 |ROLLBACK|30|

위 상황에서 T1은 데이터베이스에 반영되지 않은 A값으로 로직을 수행합니다.
앞으로 소개할 읽기 문제들이 모두 이러한 문제를 가지고 있지만 **데이터베이스에 반영**되지 않은 값으로 로직을 수행한다는 점에서 가장 큰 문제라고 볼 수 있습니다.
이 경우 다른 트랜잭션 T3가 A 값을 읽고 같은 로직을 수행했을 때 다른 결과가 나올 수 있다는 문제가 있습니다.

## 반복 불가능 읽기(Non-Repeatable Read) 문제
반복 불가능 읽기 문제는 같은 트랜잭션에서 같은 데이터를 두 번 읽는 사이에 다른 트랜잭션이 값을 변경하여 발생하는 문제입니다.
반복 불가능 읽기 문제는 오손 읽기 문제와 비슷하지만 데이터베이스에 반영된 유효한 데이터를 읽는다는 점에서 다릅니다.
다음 표를 보시겠습니다.

|       트랜잭션 T1(읽기)       | 트랜잭션 T2(쓰기) | A  |
|:-----------------------:|:-----------:|:--:|
|            -            |      -      | 30 |
|    A가 30임을 확인(read)     |      -      | 30 |
| A=30을 바탕으로 애플리케이션 로직 수행 | A=21로 업데이트  | 21 |
|    A가 21임을 확인(read)     | - | 21 |
| A=21을 바탕으로 애플리케이션 로직 수행 ||30|

위 상황에서 T1이라는 하나의 트랜잭션 내에서 같은 데이터 A를 조회했지만 다른 값으로 로직이 수행됩니다.
데이터 A가 데이터베이스에 반영되어 있다는 점에서 오손 읽기와 다르지만, 다른 값을 바탕으로 로직이 수행된다는 점은 같습니다.

총 자산과 이자를 함께 계산하는 트랜잭션을 예로 들어보겠습니다. 
계좌에 1,000원이 있는 상태에서 총 자산을 계산하고 이제 1,000원에 대한 이자를 계산하려고 하는데
그 사이에 1,000원이 입금되면 1,000원이 아닌 2,000원에 대한 이자를 계산하게 됩니다. 즉, 총 자산으로 추측할 수 있는 이자와
실제 계산된 이자가 달라지는 결과가 발생합니다.
이 경우 데이터베이스의 일관성이 훼손됐다고 볼 수 있습니다.

## 유령 데이터 읽기(Phantom Data Read) 문제
유령 데이터 읽기 문제는 하나의 트랜잭션이 같은 데이터를 두 번 조회했을 때 다른 트랜잭션이 데이터를 추가하거나 삭제해서 발생하는 문제입니다.
반복 불가능 읽기 문제와 비슷하지만 새로운 데이터가 추가되거나 삭제된다는 점에서 다릅니다.
다음 표를 보시겠습니다.

|      트랜잭션 T1(읽기)      | 트랜잭션 T2(쓰기) | A  |
|:---------------------:|:-----------:|:--:|
|           -           |      -      | 30 |
|   A가 30임을 확인(read)    |      -      | 30 |
|           -           |   A=50 추가   |30<br>50|
| A={30, 50}임을 확인(read) |      -      |30<br>50|

위 과정에서 같은 쿼리를 수행했을 때 이전에 없던 데이터(유령 데이터)가 보이게 됩니다.

## 문제 해결 방법 - 트랜잭션 고립 수준
###### 문제 해결 방법은 [이 글](https://mangkyu.tistory.com/299)을 참고하여 작성하였습니다.
오손 읽기, 반복 불가능 읽기, 유령 읽기 문제는 모두 트랜잭션의 고립이 보장되지 않았기 때문에 발생하는 문제입니다.
따라서 트랜잭션을 고립시킨다면 이 문제를 해결할 수 있습니다.
하지만 쓰기 - 쓰기 상황처럼 문제가 아예 발생하지 않도록 락을 사용하면 동시성이 과하게 제한될 수 있습니다.
그래서 DBMS는 트랜잭션의 고립 수준을 사용자가 정할 수 있게 하여 동시성을 어느 정도 보장해줍니다.
트랜잭션의 고립 수준을 정하는 명령어를 **트랜잭션 고립 수준 명령어**라고 합니다.

아래는 트랜잭션 고립 수준에 따른 동시성 허용 범위입니다. 이제 각 고립 수준에 대해 알아보겠습니다.

|        고립 수준        | 오손 읽기  | 반복 불가능 읽기  | 유령 데이터 읽기  |
|:-------------------:|:------:|:----------:|:----------:|
|  READ UNCOMMITTED   |   가능   |     가능     |     가능     |
| READ COMMITTED  |  불가능   |     가능     |     가능     |
| REPEATABLE READ |  불가능   |    불가능     |     가능     |
|  SERIALIZABLE   |  불가능   |    불가능     |    불가능     |

### READ UNCOMMITTED
커밋되지 않은 데이터를 읽을 수 있는 고립 수준으로, 읽기 작업에 공유락이 필수가 아닙니다.
갱신 손실을 방지하기 위한 [베타락](#베타락exclusive-lock-x-lock)을 제외하고는 아무런 락을 사용하지 않습니다.

> 베타락이 걸린 데이터의 공유락은 얻을 수 없는데 어떻게 데이터를 읽을 수 있나요?

공유락은 필요에 의해 사용되는 것이지 공유락이 있어야만 데이터를 읽을 수 있는 것은 아닙니다.
즉, 원래 데이터는 공유락 없이도 읽을 수 있습니다. 다만 갱신 손실과 같은 문제를 방지하기 위하여 공유락, 베타락과 같은 락이 도입된 것입니다.
따라서 **데이터에 베타락이 걸려있다고 해도 시스템적으로 공유락이 읽기 작업에 필수가 아니라면 공유락 없이도 해당 데이터를 읽을 수 있습니다.**
이 고립 수준에서는 오손 일기, 반복 불가능 읽기, 유령 데이터 읽기 문제가 발생합니다.

### READ COMMITTED
커밋된 데이터만 읽을 수 있는 고립 수준입니다.
오손 읽기 문제를 방지하기 위해 데이터를 읽을 때 [공유락](#공유락shared-lock-s-lock)을 획득하는 것이 필수입니다.
데이터를 수정 중인 트랜잭션이 베타락을 획득하므로 해당 데이터에 대한 공유락은 수정 작업이 끝날 때까지 얻을 수 없습니다.
따라서 오손 읽기 문제를 방지할 수 있습니다.
하지만 여전히 반복 불가능 읽기, 유령 데이터 읽기 문제는 발생합니다.

### REPEATABLE READ
하나의 트랜잭션 내에서 동일한 결과를 보장하지만 새로운 레코드가 추가되는 경우에는 동일한 결과를 보장하지 못하는 고립 수준입니다.
이 고립 수준을 구현하기 위해 [MVCC(Multi-Version Concurrency Control, 다중 버전 동시성 제어)](./MVCC.md)가 사용됩니다.
RDBMS는 보통 트랜잭션으로 인해 변경되기 전의 레코드를 언두(undo) 공간에 백업해둡니다.
이 경우 동일한 데이터가 여러 버전으로 관리되는데 이를 MVCC라고 합니다.

각각의 트랜잭션은 순차적으로 증가하는 고유한 트랜잭션을 가지고 있고 백업된 레코드는 해당 백업을 만든 트랜잭션의 번호를 함께 저장합니다.
REPEATABLE READ 고립 수준에서는 테이블에 자신보다 이후에 시작한 트랜잭션의 데이터가 존재한다면 언두 백업을 참고해서 데이터를 조회합니다.
즉, REPEATABLE READ 고립 수준은 어떤 데이터를 반복적으로 조회할 때 다른 트랜잭션이 해당 데이터를 수정하더라도
동일한 결과를 반환할 것을 보장합니다.

### SERIALIZABLE
가장 엄격한 고립 수준으로 각각의 트랜잭션이 순차적으로 실행되는 것을 보장합니다.
하지만 그만큼 동시 처리 성능은 떨어집니다.

# 참조
Mysql로 배우는 데이터베이스 개론과 실습<br>
https://velog.io/@paki1019/%EA%B3%B5%EC%9C%A0-%EB%9D%BDShared-Lock%EA%B3%BC-%EB%B2%A0%ED%83%80-%EB%9D%BDExclusive-Lock<br>
https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html#innodb-shared-exclusive-locks<br>
https://mangkyu.tistory.com/299
